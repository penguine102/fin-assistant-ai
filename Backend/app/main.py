from fastapi import FastAPI
from contextlib import asynccontextmanager
from fastapi.responses import JSONResponse
from starlette.middleware.cors import CORSMiddleware
from sqlalchemy import text
import logging

from app.core.config import settings
from app.api.v1.routes import api_router
from app.core.logging import configure_logging
from app.exceptions.handlers import register_exception_handlers
from app.modules.ocr_expense.exceptions import register_ocr_exception_handlers
# OCR exception handlers removed - using simplified approach
from app.middlewares.request_context import RequestContextMiddleware
from app.db.session import engine
from app.redis.client import ping as redis_ping, close as redis_close
from fastapi.openapi.utils import get_openapi


@asynccontextmanager
async def lifespan(app: FastAPI):
    logger = logging.getLogger(__name__)
    # Startup
    if not settings.SKIP_STARTUP_CHECKS:
        try:
            # Kiểm tra kết nối Database
            from sqlalchemy import text as _text
            async with engine.begin() as conn:
                await conn.execute(_text("SELECT 1"))
            logger.info("Database connectivity check succeeded")
        except Exception as exc:
            logger.exception("Database connectivity check failed: %s", exc)
            raise
        # Kiểm tra kết nối Redis
        ok = await redis_ping()
        if not ok:
            # Cho nổ lỗi để container/app fail fast nếu Redis không sẵn sàng
            raise RuntimeError("Redis is not reachable at startup")

    try:
        yield
    finally:
        # Shutdown
        try:
            await redis_close()
        except Exception:
            pass
        await engine.dispose()


def create_app() -> FastAPI:
    configure_logging(level=settings.LOG_LEVEL)
    logger = logging.getLogger(__name__)

    application = FastAPI(
        title="API",
        version="1.0.0",
        openapi_url=f"{settings.API_PREFIX}/openapi.json",
        docs_url="/docs",
        redoc_url="/redoc",
        lifespan=lifespan,
    )

    # CORS MUST be added FIRST before other middlewares
    application.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Allow all origins
        allow_credentials=True,  # Allow cookies
        allow_methods=["*"],  # Allow all methods
        allow_headers=["*"],  # Allow all headers
        expose_headers=["*"],  # Expose all headers
    )

    application.add_middleware(RequestContextMiddleware)

    application.include_router(api_router, prefix=settings.API_PREFIX)
    register_exception_handlers(application)
    register_ocr_exception_handlers(application)

    @application.get("/health", tags=["health"])  # simple liveness
    async def health() -> JSONResponse:
        return JSONResponse({"status": "ok"})

    # Custom OpenAPI override to rename multipart body schema for OCR extract
    def custom_openapi():
        if application.openapi_schema:
            return application.openapi_schema
        openapi_schema = get_openapi(
            title=application.title,
            version=application.version,
            routes=application.routes,
        )
        try:
            components = openapi_schema.get("components", {}).get("schemas", {})
            # Original autogenerated name FastAPI gives to multipart body for this route
            original_key = "Body_extract_expense_sync_api_v1_ocr_expense_extract_post"
            target_key = "OcrExpenseExtractRequest"
            if original_key in components and target_key not in components:
                components[target_key] = components.pop(original_key)
                try:
                    schema_obj = components.get(target_key, {})
                    # Overwrite the autogenerated title to our desired schema name
                    if isinstance(schema_obj, dict):
                        schema_obj["title"] = target_key
                except Exception:
                    pass
                # Update $ref in path requestBody
                paths = openapi_schema.get("paths", {})
                ocr_path = "/api/v1/ocr/expense:extract"
                if ocr_path in paths:
                    post_op = paths[ocr_path].get("post", {})
                    rb = post_op.get("requestBody", {})
                    content = rb.get("content", {})
                    mfd = content.get("multipart/form-data", {})
                    schema = mfd.get("schema", {})
                    if "$ref" in schema and original_key in schema["$ref"]:
                        schema["$ref"] = f"#/components/schemas/{target_key}"
        except Exception:
            # Fail-safe: if any shape changes, don't break OpenAPI generation
            pass
        application.openapi_schema = openapi_schema
        return application.openapi_schema

    application.openapi = custom_openapi

    return application


app = create_app()



# Expose a stable alias for test clients and external imports
application = app

